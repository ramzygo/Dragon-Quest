<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dragon Spirit: Stable Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            touch-action: none;
            font-family: 'Noto Serif JP', 'Georgia', serif; 
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .hud-text {
            position: absolute;
            z-index: 10;
            font-weight: bold;
            font-family: 'Noto Serif JP', serif;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            pointer-events: none;
            transition: font-family 0.3s;
        }

        #highScoreBoard { top: 10px; left: 15px; font-size: 16px; color: #8b2e2e; letter-spacing: 1px; text-transform: uppercase; }
        #walletBoard { top: 35px; left: 15px; font-size: 16px; color: #d4af37; letter-spacing: 1px; }
        #coinBoard { top: 10px; right: 15px; font-size: 16px; color: #fff; text-shadow: 1px 1px 0 #000; letter-spacing: 1px; }
        
        #levelIndicator { 
            position: absolute; width: 100%; top: 40px; text-align: center; font-size: 14px; 
            color: #2f5d87; font-style: italic; pointer-events: none; z-index: 10; 
        }

        #scoreBoard { 
            position: absolute; width: 100%; top: 15%; text-align: center; font-size: 60px; 
            font-weight: bold; color: #2c2c2c; text-shadow: 0px 0px 5px #f0e6d2; pointer-events: none; z-index: 5; 
        }

        #statusMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 30px; color: #fff; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 45; display: none; text-align: center;
            width: 100%;
        }

        #pauseOverlay {
            display: none;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; color: #fff; background: rgba(0,0,0,0.7);
            padding: 20px 50px; border-radius: 10px; pointer-events: none; z-index: 40;
            text-transform: uppercase; letter-spacing: 5px;
        }

        #instruction {
            position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: #f0e6d2; background-color: #b83b3b;
            padding: 15px 30px; border: 2px solid #2c2c2c; border-radius: 4px;
            box-shadow: 4px 4px 0px #2c2c2c; pointer-events: none; text-align: center;
            z-index: 30; width: 80%;
        }

        /* Shop & Math Styles */
        #shopOverlay, #mathOverlay {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 450px; background-color: #f0e6d2; border: 4px solid #2c2c2c;
            border-radius: 8px; padding: 15px; box-shadow: 10px 10px 0px rgba(0,0,0,0.5);
            z-index: 50; text-align: center; flex-direction: column;
        }
        #shopOverlay { height: 85%; }
        #mathOverlay { height: auto; z-index: 60; } 

        .shop-header { flex: 0 0 auto; }
        .shop-title { font-size: 28px; color: #8b2e2e; margin-bottom: 5px; border-bottom: 2px solid #2c2c2c; padding-bottom: 5px; }
        .shop-wallet { font-size: 20px; color: #d4af37; text-shadow: 1px 1px 0 #000; margin-bottom: 10px; font-weight: bold; }
        
        #cheatBtn {
            background-color: #555; color: #fff; border: 1px solid #000; padding: 5px 10px;
            margin-bottom: 10px; cursor: pointer; font-size: 12px; font-family: 'Noto Serif JP', serif; width: 100%;
        }
        #cheatBtn.active { background-color: #2ecc71; font-weight: bold; }

        .shop-tabs { display: flex; justify-content: space-around; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .tab-btn { background: none; border: none; font-size: 16px; font-family: 'Noto Serif JP', serif; cursor: pointer; color: #555; font-weight: bold; }
        .tab-btn.active { color: #b83b3b; text-decoration: underline; }

        .shop-content { flex: 1 1 auto; overflow-y: auto; margin-bottom: 15px; padding-right: 5px; }
        
        .shop-item {
            display: flex; justify-content: space-between; align-items: center; background: #fff;
            padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 8px;
        }
        .item-info { text-align: left; }
        .item-name { font-size: 16px; font-weight: bold; color: #2c2c2c; }
        .item-desc { font-size: 12px; color: #555; }
        .buy-btn {
            background-color: #2f5d87; color: white; border: none; padding: 8px 12px;
            font-family: 'Noto Serif JP', serif; font-weight: bold; cursor: pointer;
            border-radius: 4px; min-width: 80px;
        }
        .buy-btn:disabled { background-color: #ccc; color: #666; cursor: not-allowed; }
        .equip-btn { background-color: #2c2c2c; color: #fff; }
        .maxed-btn { background-color: #8b2e2e; color: white; cursor: default; }

        #restartBtn {
            flex: 0 0 auto; background-color: #b83b3b; color: #f0e6d2; font-size: 20px;
            padding: 15px 30px; border: 2px solid #2c2c2c; box-shadow: 4px 4px 0 #2c2c2c;
            cursor: pointer; width: 100%;
        }

        #mathQ { font-size: 24px; margin: 15px 0; color: #2c2c2c; font-weight: bold; }
        #mathAns { font-size: 20px; padding: 5px; width: 100px; text-align: center; border: 2px solid #2c2c2c; font-family: 'Noto Serif JP', serif; }
        #mathMsg { color: #b83b3b; font-size: 14px; min-height: 20px; margin-top:5px; }

        .flash-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 25; }
        #damageFlash { background-color: rgba(184, 59, 59, 0.4); }
        #healFlash { background-color: rgba(212, 175, 55, 0.3); }
        #shieldFlash { background-color: rgba(47, 93, 135, 0.5); }
        
        .control-hint {
            position: absolute; bottom: 20px; font-size: 14px; color: rgba(255,255,255,0.5);
            font-weight: bold; pointer-events: none; z-index: 20;
        }
        #leftHint { left: 20px; text-align: left; }
        #rightHint { right: 20px; text-align: right; }

        .texture-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.15;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            z-index: 20;
        }
        
        #healthBarArea {
            position: absolute;
            top: 60px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 30px;
            z-index: 15;
            cursor: pointer;
        }
        
        .coin-float {
            position: absolute;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 40;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <div class="texture-overlay"></div>
    <div id="damageFlash" class="flash-overlay"></div>
    <div id="healFlash" class="flash-overlay"></div>
    <div id="shieldFlash" class="flash-overlay"></div>
    <div id="pauseOverlay">PAUSED</div>
    
    <!-- HUD -->
    <div id="highScoreBoard" class="hud-text">Best: <span id="hsValue">0</span></div>
    <div id="walletBoard" class="hud-text">Wallet: <span id="walletGameValue">0</span></div>
    <div id="coinBoard" class="hud-text">Run: <span id="coinValue">0</span></div>
    
    <div id="levelIndicator">Peaceful Era</div>
    <div id="scoreBoard"><span id="scoreValue">0</span></div>
    
    <div id="statusMessage" class="hud-text"></div>

    <!-- Invisible click target for health bar pausing -->
    <div id="healthBarArea"></div>

    <div id="instruction">
        TAP RIGHT to Fly<br>
        <span id="fireInstruct">TAP LEFT to Shoot</span>
    </div>

    <div id="leftHint" class="control-hint">Tap Area: FIRE</div>
    <div id="rightHint" class="control-hint">Tap Area: FLY</div>

    <!-- MATH OVERLAY -->
    <div id="mathOverlay">
        <div class="shop-title">Wisdom Test</div>
        <div id="mathProgress">Question 1 / 5</div>
        <div id="mathQ">2 x 2 = ?</div>
        <input type="number" id="mathAns" placeholder="?">
        <div id="mathMsg"></div>
        <button onclick="submitMathAnswer()" class="buy-btn" style="margin-top:15px; width:100%;">Submit Answer</button>
        <button onclick="closeMath()" class="buy-btn" style="margin-top:10px; width:100%; background-color:#555;">Cancel</button>
    </div>

    <!-- SHOP MENU -->
    <div id="shopOverlay" style="display:none;">
        <div class="shop-header">
            <div class="shop-title">Spirit Merchant</div>
            <button id="cheatBtn" onclick="tryToggleCheat()">Cheat Mode: OFF</button>
            <div class="shop-wallet">Wallet: <span id="shopWalletVal">0</span> Koban</div>
            <div class="shop-tabs">
                <button class="tab-btn active" onclick="switchTab('items')">Items</button>
                <button class="tab-btn" onclick="switchTab('skills')">Skills</button>
                <button class="tab-btn" onclick="switchTab('style')">Style</button>
            </div>
        </div>
        
        <div class="shop-content" id="shopItems">
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Omamori Barrier</div><div class="item-desc">Shields 3 hits (Next Run)</div></div>
                <button id="btnBuyShield" class="buy-btn" onclick="buyItem('shield', 50)">50</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Magnet Spirit</div><div class="item-desc">Attracts coins (Next Run)</div></div>
                <button id="btnBuyMagnet" class="buy-btn" onclick="buyItem('magnet', 15)">15</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Iron Scales</div><div class="item-desc">+20 Max Health (Perm)</div></div>
                <button id="btnBuyHealth" class="buy-btn" onclick="buyItem('health', 100)">100</button>
            </div>
        </div>

        <div class="shop-content" id="shopSkills" style="display:none;">
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Scroll of Fire</div><div class="item-desc">Unlock Fire Breath Attack</div></div>
                <button id="btnBuyFire" class="buy-btn" onclick="buyItem('fire', 250)">250</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Time Scroll</div><div class="item-desc">Unlock Slow Mo Mode</div></div>
                <button id="btnBuyTime" class="buy-btn" onclick="buyOrEquip('time', 'unlocked', 400)">400</button>
            </div>
        </div>

        <div class="shop-content" id="shopStyle" style="display:none;">
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Vermilion Dragon</div><div class="item-desc">Classic Red</div></div>
                <button id="btnSkinDefault" class="buy-btn equip-btn" onclick="equipItem('skin', 'default')">Equipped</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Azure Dragon</div><div class="item-desc">Spirit Blue</div></div>
                <button id="btnSkinAzure" class="buy-btn" onclick="buyOrEquip('skin', 'azure', 200)">200</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Golden Dragon</div><div class="item-desc">Emperor's Gold</div></div>
                <button id="btnSkinGold" class="buy-btn" onclick="buyOrEquip('skin', 'gold', 500)">500</button>
            </div>
            <div class="shop-item" style="border-top: 2px solid #2c2c2c; margin-top: 15px;">
                <div class="item-info"><div class="item-name">Paper Theme</div><div class="item-desc">Classic</div></div>
                <button id="btnThemeDefault" class="buy-btn equip-btn" onclick="equipItem('theme', 'default')">Equipped</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Midnight Theme</div><div class="item-desc">Dark Night Mode</div></div>
                <button id="btnThemeNight" class="buy-btn" onclick="buyOrEquip('theme', 'night', 300)">300</button>
            </div>
            <div class="shop-item">
                <div class="item-info"><div class="item-name">Unicorn Dream</div><div class="item-desc">Total Conversion Mode</div></div>
                <button id="btnThemeUnicorn" class="buy-btn" onclick="buyOrEquip('theme', 'unicorn', 600)">600</button>
            </div>
        </div>

        <button id="restartBtn" onclick="resetGame()">Reincarnate</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreValue');
        const highScoreEl = document.getElementById('hsValue');
        const walletGameEl = document.getElementById('walletGameValue');
        const coinEl = document.getElementById('coinValue');
        const instructionEl = document.getElementById('instruction');
        const levelEl = document.getElementById('levelIndicator');
        const fireInstructEl = document.getElementById('fireInstruct');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const healthBarArea = document.getElementById('healthBarArea');
        const statusMessageEl = document.getElementById('statusMessage');
        
        // Shop UI
        const shopOverlay = document.getElementById('shopOverlay');
        const shopWalletVal = document.getElementById('shopWalletVal');
        const cheatBtn = document.getElementById('cheatBtn');
        
        // Math UI
        const mathOverlay = document.getElementById('mathOverlay');
        const mathQ = document.getElementById('mathQ');
        const mathAns = document.getElementById('mathAns');
        const mathProgress = document.getElementById('mathProgress');
        const mathMsg = document.getElementById('mathMsg');

        // Colors
        let themeColors = {
            bg: '#f0e6d2', text: '#2c2c2c', sun: '#b83b3b', water: '#2f5d87',
            bambooLight: '#8FA875', bambooDark: '#5E7048', bambooShadow: '#3e4a2e', 
            bambooWeak: '#ded895', gold: '#d4af37'
        };

        const dragonColors = {
            default: { body: '#c44e43', trim: '#d4af37' },
            azure: { body: '#2f5d87', trim: '#a8d8e6' },
            gold: { body: '#d4af37', trim: '#fff' }
        };

        // --- Persistent Data ---
        let playerData = {
            totalCoins: 0,
            highScore: 0,
            maxHealthLevel: 0, 
            hasShield: false,
            shieldCharges: 0,
            hasMagnet: false,
            hasFireBreath: false,
            hasSlowMo: false,
            slowMoEquipped: false,
            unlockedSkins: ['default'],
            unlockedThemes: ['default'],
            currentSkin: 'default',
            currentTheme: 'default'
        };

        let cheatMode = false;
        let isPaused = false;
        // Global to store checkpoint
        let savedCheckpointScore = 0;

        function loadData() {
            const saved = localStorage.getItem('dragonSpiritSaveCheckV2');
            if (saved) {
                const loaded = JSON.parse(saved);
                playerData = { ...playerData, ...loaded };
            }
        }
        function saveData() {
            localStorage.setItem('dragonSpiritSaveCheckV2', JSON.stringify(playerData));
        }
        loadData();

        // --- Game Variables ---
        let frames = 0;
        let score = 0;
        let runCoins = 0;
        let gameState = 'start'; 
        const gravity = 0.25;
        let gameSpeed = 2.5; 
        let speedMultiplier = 1.0; 
        
        let baseMaxHealth = 100;
        let maxHealth = 100;
        let currentHealth = 100;
        
        let enemySpawnRate = 0; 
        let coinSpawnRate = 0.005;
        let invulnerable = 0; 

        // BOSS VARS
        let currentBoss = null;
        let bossProjectiles = [];

        let animationId;
        let clouds = [];
        highScoreEl.innerText = playerData.highScore;
        walletGameEl.innerText = playerData.totalCoins; 

        // --- Drawing Helpers ---
        function drawBambooSegment(x, y, w, h, isWeak) {
            ctx.fillStyle = isWeak ? themeColors.bambooWeak : themeColors.bambooLight; 
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = isWeak ? 'rgba(0,0,0,0.1)' : themeColors.bambooDark; 
            ctx.fillRect(x + w - 10, y, 10, h);
            ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
            ctx.strokeStyle = themeColors.bambooShadow; ctx.lineWidth = 2;
            let startY = y; while(startY < y + h) { ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x + w, startY); ctx.stroke(); startY += 60; }
        }

        function drawCoin(c) {
            if(c.collected) return;
            ctx.save(); ctx.translate(c.x, c.y);
            
            if (playerData.currentTheme === 'unicorn') {
                ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.arc(-6, 4, 8, 0, Math.PI*2); ctx.fill(); 
                ctx.beginPath(); ctx.arc(6, 4, 8, 0, Math.PI*2); ctx.fill(); 
                ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-6, -2); ctx.quadraticCurveTo(0, -15, 6, -2); ctx.stroke(); 
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-8, 2, 2, 0, Math.PI*2); ctx.fill(); 
            } else {
                ctx.fillStyle = themeColors.gold; ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.ellipse(0, 0, c.w/2, c.h/2, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = '#b8860b'; ctx.fillRect(-5, -8, 10, 4); ctx.fillRect(-5, -2, 10, 4); ctx.fillRect(-5, 4, 10, 4);
                ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.ellipse(-4, -6, 4, 6, -0.5, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes;
            ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
                x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
            ctx.fillStyle = '#fff700'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.stroke();
        }

        function createFloatingText(x, y, text) {
            const div = document.createElement('div');
            div.className = 'coin-float';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.innerText = text;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        // --- Shop Logic ---
        function switchTab(tabName) {
            document.getElementById('shopItems').style.display = 'none';
            document.getElementById('shopSkills').style.display = 'none';
            document.getElementById('shopStyle').style.display = 'none';
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(b => b.classList.remove('active'));
            document.getElementById('shop'+ tabName.charAt(0).toUpperCase() + tabName.slice(1)).style.display = 'block';
            event.target.classList.add('active');
        }

        function updateShopUI() {
            shopWalletVal.innerText = playerData.totalCoins;
            walletGameEl.innerText = playerData.totalCoins; 

            updateBtnState(document.getElementById('btnBuyShield'), playerData.hasShield, 50, "OWNED (3)");
            updateBtnState(document.getElementById('btnBuyMagnet'), playerData.hasMagnet, 15, "OWNED");
            const btnHealth = document.getElementById('btnBuyHealth');
            if (playerData.maxHealthLevel >= 5) { btnHealth.innerText = "MAX"; btnHealth.disabled = true; btnHealth.classList.add('maxed-btn'); }
            else { btnHealth.innerText = "100"; btnHealth.disabled = !(cheatMode || playerData.totalCoins >= 100); btnHealth.classList.remove('maxed-btn'); }
            updateBtnState(document.getElementById('btnBuyFire'), playerData.hasFireBreath, 250, "UNLOCKED");
            updateTimeBtn();
            updateStyleBtn('btnSkinAzure', 'skin', 'azure', 200);
            updateStyleBtn('btnSkinGold', 'skin', 'gold', 500);
            updateStyleBtn('btnThemeNight', 'theme', 'night', 300);
            updateStyleBtn('btnThemeUnicorn', 'theme', 'unicorn', 600); 
            updateEquipLabel('btnSkinDefault', 'skin', 'default');
            updateEquipLabel('btnThemeDefault', 'theme', 'default');
        }

        function updateBtnState(btn, condition, cost, ownedText) {
            if (condition) { btn.innerText = ownedText; btn.disabled = true; btn.classList.add('maxed-btn'); }
            else { btn.innerText = cost; btn.disabled = !(cheatMode || playerData.totalCoins >= cost); btn.classList.remove('maxed-btn'); }
        }

        function updateTimeBtn() {
            const btn = document.getElementById('btnBuyTime');
            if (playerData.hasSlowMo) {
                if (playerData.slowMoEquipped) { btn.innerText = "Enabled"; btn.className = "buy-btn maxed-btn"; }
                else { btn.innerText = "Enable"; btn.className = "buy-btn equip-btn"; }
                btn.disabled = false;
                btn.onclick = () => { playerData.slowMoEquipped = !playerData.slowMoEquipped; saveData(); updateShopUI(); };
            } else {
                btn.innerText = "400"; btn.className = "buy-btn";
                btn.disabled = !(cheatMode || playerData.totalCoins >= 400);
                btn.onclick = () => buyOrEquip('time', 'unlocked', 400);
            }
        }

        function updateStyleBtn(btnId, type, name, cost) {
            const btn = document.getElementById(btnId);
            const list = type === 'skin' ? playerData.unlockedSkins : playerData.unlockedThemes;
            const current = type === 'skin' ? playerData.currentSkin : playerData.currentTheme;
            if (list.includes(name)) {
                if (current === name) { btn.innerText = "Equipped"; btn.className = "buy-btn maxed-btn"; btn.onclick = null; } 
                else { btn.innerText = "Equip"; btn.className = "buy-btn equip-btn"; btn.onclick = () => equipItem(type, name); }
            } else {
                btn.innerText = cost; btn.className = "buy-btn";
                btn.disabled = !(cheatMode || playerData.totalCoins >= cost);
                btn.onclick = () => buyOrEquip(type, name, cost);
            }
        }

        function updateEquipLabel(btnId, type, name) {
            const btn = document.getElementById(btnId);
            const current = type === 'skin' ? playerData.currentSkin : playerData.currentTheme;
            if (current === name) { btn.innerText = "Equipped"; btn.className = "buy-btn maxed-btn"; } 
            else { btn.innerText = "Equip"; btn.className = "buy-btn equip-btn"; }
        }

        function buyItem(item, cost) {
            if (cheatMode || playerData.totalCoins >= cost) {
                if (!cheatMode) playerData.totalCoins -= cost; 
                if (item === 'shield') { playerData.hasShield = true; playerData.shieldCharges = 3; }
                if (item === 'magnet') playerData.hasMagnet = true;
                if (item === 'health') playerData.maxHealthLevel++;
                if (item === 'fire') { playerData.hasFireBreath = true; if(fireInstructEl) fireInstructEl.style.display = 'block'; }
                saveData(); updateShopUI();
            }
        }

        function buyOrEquip(type, name, cost) {
            if (cheatMode || playerData.totalCoins >= cost) {
                if (!cheatMode) playerData.totalCoins -= cost;
                if (type === 'skin') playerData.unlockedSkins.push(name);
                if (type === 'theme') playerData.unlockedThemes.push(name);
                if (type === 'time') { playerData.hasSlowMo = true; playerData.slowMoEquipped = true; }
                if (type !== 'time') equipItem(type, name);
                saveData(); updateShopUI();
            }
        }

        function equipItem(type, name) {
            if (type === 'skin') playerData.currentSkin = name;
            if (type === 'theme') playerData.currentTheme = name;
            applyTheme(); saveData(); updateShopUI();
        }

        function applyTheme() {
            const hudElements = document.querySelectorAll('.hud-text');
            
            if (playerData.currentTheme === 'unicorn') {
                themeColors = { 
                    bg: '#ffebf0', text: '#5e2a40', sun: '#ffcc00', water: '#81ecec',
                    bambooLight: '#a29bfe', bambooDark: '#6c5ce7', bambooShadow: '#fff', bambooWeak: '#ffcccc', gold: '#ff4d4d'
                };
                document.body.style.backgroundColor = '#ffebf0';
                levelEl.style.color = '#e056fd'; scoreEl.style.color = '#5e2a40';
                hudElements.forEach(el => el.style.fontFamily = "'Fredoka One', cursive");
            } else if (playerData.currentTheme === 'night') {
                themeColors = { 
                    bg: '#1a1a2e', text: '#e0e0e0', sun: '#8b0000', water: '#0f3460',
                    bambooLight: '#556b2f', bambooDark: '#2f4f4f', bambooShadow: '#000', bambooWeak: '#8fbc8f', gold: '#d4af37'
                };
                document.body.style.backgroundColor = '#1a1a2e';
                levelEl.style.color = '#a8d8e6'; scoreEl.style.color = '#fff';
                hudElements.forEach(el => el.style.fontFamily = "'Noto Serif JP', serif");
            } else {
                themeColors = { 
                    bg: '#f0e6d2', text: '#2c2c2c', sun: '#b83b3b', water: '#2f5d87',
                    bambooLight: '#8FA875', bambooDark: '#5E7048', bambooShadow: '#3e4a2e', bambooWeak: '#ded895', gold: '#d4af37'
                };
                document.body.style.backgroundColor = '#f0e6d2';
                levelEl.style.color = '#2f5d87'; scoreEl.style.color = '#2c2c2c';
                hudElements.forEach(el => el.style.fontFamily = "'Noto Serif JP', serif");
            }
        }

        // --- Math Challenge Logic ---
        let currentMathQ = 0;
        let expectedAnswer = 0;

        function tryToggleCheat() {
            if (cheatMode) {
                cheatMode = false; cheatBtn.innerText = "Cheat Mode: OFF"; cheatBtn.className = ""; updateShopUI();
            } else {
                startMathChallenge();
            }
        }

        function startMathChallenge() {
            mathOverlay.style.display = 'flex'; currentMathQ = 0; mathMsg.innerText = ""; generateMathQ();
        }

        function generateMathQ() {
            currentMathQ++; mathProgress.innerText = `Question ${currentMathQ} / 5`;
            const a = Math.floor(Math.random() * 11) + 2; const b = Math.floor(Math.random() * 11) + 2;
            expectedAnswer = a * b;
            mathQ.innerText = `${a} x ${b} = ?`; mathAns.value = ""; mathAns.focus();
        }

        function submitMathAnswer() {
            const val = parseInt(mathAns.value);
            if (val === expectedAnswer) {
                if (currentMathQ >= 5) {
                    mathOverlay.style.display = 'none'; cheatMode = true;
                    cheatBtn.innerText = "Cheat Mode: ON"; cheatBtn.className = "active";
                    updateShopUI(); alert("Wisdom Proven. Cheat Mode Activated.");
                } else {
                    mathMsg.innerText = "Correct!"; setTimeout(() => { mathMsg.innerText = ""; generateMathQ(); }, 500);
                }
            } else {
                mathMsg.innerText = "Incorrect. Access Denied."; setTimeout(() => { closeMath(); }, 1000);
            }
        }

        function closeMath() { mathOverlay.style.display = 'none'; }

        // --- Game Logic ---
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; initClouds(); }
        window.addEventListener('resize', resize);
        function initClouds() {
            clouds = [];
            for(let i=0; i<5; i++) clouds.push({x: Math.random()*canvas.width, y: Math.random()*(canvas.height/2), w: 60+Math.random()*100, speed: 0.2+Math.random()*0.3});
        }
        resize(); applyTheme();

        // --- PAUSE ---
        healthBarArea.addEventListener('click', (e) => {
            e.stopPropagation(); isPaused = !isPaused; pauseOverlay.style.display = isPaused ? 'block' : 'none';
        });

        // --- BOSS LOGIC ---
        function initBoss() {
            gameState = 'boss';
            const difficulty = Math.floor(score / 25);
            const isUnicorn = playerData.currentTheme === 'unicorn';
            
            currentBoss = {
                x: canvas.width + 100, y: canvas.height / 2,
                hp: 15 + (difficulty * 5), maxHp: 15 + (difficulty * 5),
                angle: 0, guns: [], moveTimer: 0
            };

            const gunCount = Math.min(2 + difficulty, 5);
            for(let i=0; i<gunCount; i++) {
                currentBoss.guns.push({
                    relX: Math.cos(i * (Math.PI*2/gunCount)) * 60,
                    relY: Math.sin(i * (Math.PI*2/gunCount)) * 60,
                    hp: 5 + difficulty, cooldown: Math.random() * 100
                });
            }
            
            if(fireInstructEl) {
                fireInstructEl.innerText = "BOSS FIGHT! TAP LEFT TO SHOOT!";
                fireInstructEl.style.display = 'block';
            }
            document.getElementById('leftHint').style.display = 'block';
        }

        function updateBoss() {
            if (!currentBoss) return;
            if (currentBoss.x > canvas.width - 120) {
                currentBoss.x -= 1; 
            } else {
                currentBoss.moveTimer += 0.02; 
                currentBoss.y = (canvas.height/2) + Math.sin(currentBoss.moveTimer) * 80;
            }

            const difficulty = Math.floor(score / 25);
            currentBoss.guns.forEach(gun => {
                if (gun.hp > 0) {
                    gun.cooldown--;
                    if (gun.cooldown <= 0 && currentBoss.x <= canvas.width - 100) {
                        const gx = currentBoss.x + gun.relX; const gy = currentBoss.y + gun.relY;
                        const angle = Math.atan2(dragon.y - gy, dragon.x - gx);
                        bossProjectiles.push({
                            x: gx, y: gy,
                            vx: Math.cos(angle) * (4 + difficulty*0.5), vy: Math.sin(angle) * (4 + difficulty*0.5), r: 6
                        });
                        gun.cooldown = 100 - (difficulty * 5); if (gun.cooldown < 30) gun.cooldown = 30;
                    }
                }
            });
        }

        function drawBoss() {
            if (!currentBoss) return;
            const isUnicorn = playerData.currentTheme === 'unicorn';
            ctx.save(); ctx.translate(currentBoss.x, currentBoss.y);

            currentBoss.guns.forEach(gun => {
                if (gun.hp > 0) {
                    ctx.fillStyle = isUnicorn ? '#a29bfe' : '#555';
                    ctx.beginPath(); ctx.arc(gun.relX, gun.relY, 15, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#000'; ctx.stroke();
                }
            });

            if (isUnicorn) {
                ctx.fillStyle = '#636e72';
                ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(-30, -20, 40, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(30, -20, 40, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#ff7675'; 
                ctx.beginPath(); ctx.moveTo(-20, -10); ctx.lineTo(-10, 0); ctx.lineTo(-20, 10); ctx.fill();
                ctx.beginPath(); ctx.moveTo(20, -10); ctx.lineTo(10, 0); ctx.lineTo(20, 10); ctx.fill();
            } else {
                ctx.fillStyle = '#8b0000'; ctx.fillRect(-50, -50, 100, 100);
                ctx.strokeStyle = '#2c2c2c'; ctx.lineWidth = 4; ctx.strokeRect(-50, -50, 100, 100);
                ctx.fillStyle = `rgb(255, ${Math.floor(255 * (currentBoss.hp/currentBoss.maxHp))}, 0)`;
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
            }

            ctx.fillStyle = 'red'; ctx.fillRect(-50, -80, 100, 10);
            ctx.fillStyle = 'lime'; ctx.fillRect(-50, -80, 100 * (currentBoss.hp / currentBoss.maxHp), 10);
            ctx.restore();
        }

        // --- Dragon ---
        const dragon = {
            x: 80, y: 0, radius: 18, velocity: 0, jump: -6, tailHistory: [],
            draw: function() {
                const isUnicorn = playerData.currentTheme === 'unicorn';
                const style = dragonColors[playerData.currentSkin] || dragonColors.default;
                
                if (playerData.hasShield && playerData.shieldCharges > 0) {
                    ctx.strokeStyle = '#2f5d87'; ctx.lineWidth = 2;
                    for(let i=0; i<playerData.shieldCharges; i++) {
                        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 10 + (i*6), 0, Math.PI*2);
                        ctx.fillStyle = `rgba(47, 93, 135, ${0.1 + (i*0.1)})`; ctx.fill(); ctx.stroke();
                    }
                }
                
                if (playerData.hasMagnet) {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 30, 0, Math.PI*2);
                    ctx.strokeStyle = `rgba(212, 175, 55, ${0.3 + Math.sin(frames/10)*0.2})`; ctx.lineWidth = 1; ctx.stroke();
                }

                if (frames % 2 === 0) {
                    this.tailHistory.unshift({x: this.x, y: this.y});
                    if (this.tailHistory.length > 10) this.tailHistory.pop();
                }

                ctx.beginPath(); ctx.moveTo(this.x, this.y);
                for (let i = 0; i < this.tailHistory.length; i++) { ctx.lineTo(this.tailHistory[i].x - (i*2), this.tailHistory[i].y); }
                ctx.lineCap = 'round'; ctx.lineWidth = 12; 
                
                if (isUnicorn) {
                    const gradient = ctx.createLinearGradient(this.x - 30, this.y, this.x, this.y);
                    gradient.addColorStop(0, "red"); gradient.addColorStop(0.2, "orange");
                    gradient.addColorStop(0.4, "yellow"); gradient.addColorStop(0.6, "green");
                    gradient.addColorStop(0.8, "blue"); gradient.addColorStop(1, "purple");
                    ctx.strokeStyle = gradient;
                } else { ctx.strokeStyle = style.body; }
                ctx.stroke();

                if (!isUnicorn) { ctx.lineWidth = 4; ctx.strokeStyle = style.trim; ctx.stroke(); }

                if (isUnicorn) {
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(this.x + 10, this.y + 5, 12, 9, 0, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.moveTo(this.x + 2, this.y - 12); ctx.lineTo(this.x + 12, this.y - 30); ctx.lineTo(this.x + 10, this.y - 10); ctx.fill();
                    ctx.fillStyle = '#ff79c6'; ctx.beginPath(); ctx.arc(this.x - 10, this.y - 5, 8, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(this.x + 6, this.y - 4, 2.5, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = style.body; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(this.x + 10, this.y + 5, 12, 8, 0, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(this.x - 5, this.y - 10); ctx.lineTo(this.x - 10, this.y - 25); ctx.lineTo(this.x + 5, this.y - 10); ctx.fillStyle = '#1a1a1a'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x + 5, this.y - 5, 6, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#1a1a1a'; ctx.beginPath(); ctx.arc(this.x + 7, this.y - 5, 2, 0, Math.PI * 2); ctx.fill();
                }
            },
            update: function() {
                this.velocity += gravity * speedMultiplier;
                this.y += this.velocity;
                if (this.y + this.radius >= canvas.height - 40) { this.y = canvas.height - 40 - this.radius; takeDamage(1000); }
                if (this.y - this.radius <= 0) { this.y = this.radius; this.velocity = 0; }
            },
            flap: function() { this.velocity = this.jump; },
            shoot: function() {
                fireballs.push({ x: this.x + 20, y: this.y + 5, r: 8, vx: 8 });
            }
        };

        const pipes = []; const pipeWidth = 50; const pipeGap = 190; 
        const enemies = []; const coins = []; const fireballs = []; const particles = [];

        function spawnEnemy() {
            const type = Math.random() > 0.5 ? 1 : 0;
            enemies.push({ x: canvas.width + 50, y: Math.random()*(canvas.height-100)+50, r: 15, type: type, angle: 0 });
        }
        function spawnCoin() {
            coins.push({ x: canvas.width + 50, y: Math.random()*(canvas.height-200)+100, w: 25, h: 35, collected: false });
        }
        function createExplosion(x, y, color) {
            for(let i=0; i<15; i++) {
                particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 30, color: color });
            }
        }

        function takeDamage(amount, type, hitObject) {
            if (invulnerable > 0) return;
            if (playerData.hasShield && playerData.shieldCharges > 0) {
                playerData.shieldCharges--;
                if (playerData.shieldCharges <= 0) playerData.hasShield = false;
                if (type === 'bamboo') { 
                    createExplosion(dragon.x + 25, dragon.y, themeColors.bambooLight); 
                    if(hitObject) hitObject.disabled = true; 
                    dragon.velocity = -3; invulnerable = 60; 
                } else { 
                    createExplosion(dragon.x, dragon.y, '#fff'); invulnerable = 60; 
                }
                saveData(); return; 
            }
            currentHealth -= amount;
            document.getElementById('damageFlash').style.opacity = 0.6;
            setTimeout(() => document.getElementById('damageFlash').style.opacity = 0, 150);
            if (currentHealth <= 0) { currentHealth = 0; gameOver(); }
        }

        function handleGameLogic() {
            speedMultiplier = (playerData.hasSlowMo && playerData.slowMoEquipped) ? 0.7 : 1.0;
            const currentSpeed = gameSpeed * speedMultiplier;
            if (invulnerable > 0) invulnerable--;

            if (score > 0 && score % 25 === 0 && gameState !== 'boss' && !currentBoss) {
                initBoss();
                pipes.length = 0; enemies.length = 0; coins.length = 0;
            }

            if (gameState === 'boss') {
                updateBoss();
                for (let i=0; i<bossProjectiles.length; i++) {
                    let p = bossProjectiles[i];
                    p.x += p.vx * speedMultiplier; p.y += p.vy * speedMultiplier;
                    ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                    if(p.x < 0) { bossProjectiles.splice(i, 1); i--; continue; }
                    if(Math.hypot(dragon.x - p.x, dragon.y - p.y) < dragon.radius + p.r) {
                        takeDamage(maxHealth * 0.1, 'projectile', null); 
                        bossProjectiles.splice(i, 1); i--;
                    }
                }
            } else {
                if (frames % Math.floor(120 * (2.5/gameSpeed)) === 0) {
                    const topHeight = Math.floor(Math.random() * (Math.max(canvas.height - pipeGap - 140, 50) - 50 + 1) + 50);
                    pipes.push({ x: canvas.width, top: topHeight, bottom: canvas.height - topHeight - pipeGap - 40, scored: false, disabled: false, topHealth: 3, bottomHealth: 3 });
                }
                
                // SPAWN ENEMIES EARLY (Score >= 2)
                if (score >= 2 && Math.random() < enemySpawnRate) spawnEnemy();
                
                if (Math.random() < coinSpawnRate) spawnCoin();
                
                if (score < 5) { gameSpeed = 2.5; enemySpawnRate = 0.003; levelEl.innerText = "Peaceful Era"; } 
                else if (score >= 5 && score < 15) { gameSpeed = 3.0; enemySpawnRate = 0.005; levelEl.innerText = "Spirits Awaken"; } 
                else if (score >= 15 && score < 30) { gameSpeed = 3.5; enemySpawnRate = 0.01; levelEl.innerText = "Night of Demons"; } 
                else { gameSpeed = 4.0; enemySpawnRate = 0.02; levelEl.innerText = "Dragon's Fury"; }
            }

            for (let i = 0; i < fireballs.length; i++) {
                let f = fireballs[i]; f.x += f.vx;
                if (playerData.currentTheme === 'unicorn') drawStar(f.x, f.y, 5, 8, 4);
                else { ctx.beginPath(); ctx.arc(f.x, f.y, f.r, 0, Math.PI*2); ctx.fillStyle = '#ff4500'; ctx.fill(); }
                if (f.x > canvas.width) { fireballs.splice(i, 1); i--; continue; }
                
                let hit = false;
                if (gameState === 'boss' && currentBoss) {
                    if (Math.hypot(f.x - currentBoss.x, f.y - currentBoss.y) < 60) {
                        currentBoss.hp--; hit = true; createExplosion(f.x, f.y, '#fff');
                        if (currentBoss.hp <= 0) {
                            createExplosion(currentBoss.x, currentBoss.y, '#ff0000');
                            currentBoss = null; bossProjectiles = []; gameState = 'play'; score += 5; 
                            runCoins += 100; coinEl.innerText = runCoins; 
                            createFloatingText(f.x, f.y, "+100");
                            if(fireInstructEl) fireInstructEl.style.display = 'none'; 
                            if(!playerData.hasFireBreath) document.getElementById('leftHint').style.display = 'none';
                        }
                    }
                    if(!hit) {
                        for(let g of currentBoss.guns) {
                            if(g.hp > 0 && Math.hypot(f.x - (currentBoss.x+g.relX), f.y - (currentBoss.y+g.relY)) < 15) {
                                g.hp--; hit = true; createExplosion(f.x, f.y, '#555'); break;
                            }
                        }
                    }
                } else {
                    for (let j = 0; j < enemies.length; j++) {
                        if (Math.hypot(f.x - enemies[j].x, f.y - enemies[j].y) < f.r + enemies[j].r) {
                            // BOUNTY LOGIC
                            enemies.splice(j, 1); hit = true; score += 1; scoreEl.innerText = score;
                            runCoins += 5; coinEl.innerText = runCoins; 
                            createFloatingText(f.x, f.y, "+5");
                            break;
                        }
                    }
                    if (!hit) {
                        for (let k = 0; k < pipes.length; k++) {
                            let p = pipes[k];
                            if (p.x > f.x + 50 || p.x + pipeWidth < f.x - 50) continue;
                            if (!p.disabled && p.topHealth > 0 && f.x > p.x && f.x < p.x + pipeWidth) {
                                if (f.y < p.top) { 
                                    hit = true;
                                    let weakZoneStart = p.top * 0.75;
                                    if (f.y > weakZoneStart) { p.topHealth--; createExplosion(f.x, f.y, themeColors.bambooWeak); } 
                                    else { createExplosion(f.x, f.y, '#fff'); }
                                }
                            }
                            if (!hit && !p.disabled && p.bottomHealth > 0 && f.x > p.x && f.x < p.x + pipeWidth) {
                                let bottomY = canvas.height - 40 - p.bottom;
                                if (f.y > bottomY) { 
                                    hit = true;
                                    let weakZoneEnd = bottomY + (p.bottom * 0.25);
                                    if (f.y < weakZoneEnd) { p.bottomHealth--; createExplosion(f.x, f.y, themeColors.bambooWeak); } 
                                    else { createExplosion(f.x, f.y, '#fff'); }
                                }
                            }
                            if(hit) break;
                        }
                    }
                }
                if (hit) { fireballs.splice(i, 1); i--; }
            }

            pipes.forEach(p => { p.x -= currentSpeed; });
            enemies.forEach(e => { e.x -= currentSpeed * 1.2; });
            coins.forEach(c => { 
                if (playerData.hasMagnet && !c.collected && Math.hypot(dragon.x - c.x, dragon.y - c.y) < 300) {
                    c.x += (dragon.x - c.x)/20; c.y += (dragon.y - c.y)/20;
                } else c.x -= currentSpeed; 
            });
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });

            if(pipes.length && pipes[0].x < -100) pipes.shift();
            if(enemies.length && enemies[0].x < -100) enemies.shift();
            if(coins.length && coins[0].x < -100) coins.shift();
            for(let i=0; i<particles.length; i++) if(particles[i].life<=0) { particles.splice(i,1); i--; }

            if (gameState !== 'boss') {
                pipes.forEach(p => { if (p.x + pipeWidth < dragon.x && !p.scored) { score++; scoreEl.innerText = score; p.scored = true; }});
                pipes.forEach(p => {
                    if(!p.disabled) {
                        if(p.topHealth > 0 && dragon.x+dragon.radius>p.x && dragon.x-dragon.radius<p.x+pipeWidth && dragon.y-dragon.radius<p.top) takeDamage(1000, 'bamboo', p);
                        if(p.bottomHealth > 0 && dragon.x+dragon.radius>p.x && dragon.x-dragon.radius<p.x+pipeWidth && dragon.y+dragon.radius>canvas.height-40-p.bottom) takeDamage(1000, 'bamboo', p);
                    }
                });
                enemies.forEach((e, i) => {
                    if(Math.hypot(dragon.x-e.x, dragon.y-e.y) < dragon.radius+e.r) { takeDamage(35, 'enemy'); enemies.splice(i,1); }
                });
                coins.forEach(c => {
                    if(!c.collected && Math.hypot(dragon.x-c.x, dragon.y-c.y) < dragon.radius+c.w) {
                        currentHealth = Math.min(maxHealth, currentHealth+15); runCoins++; coinEl.innerText = runCoins; c.collected = true;
                        document.getElementById('healFlash').style.opacity = 0.3; setTimeout(()=>document.getElementById('healFlash').style.opacity=0, 150);
                    }
                });
            }
        }

        function drawBackground() {
            ctx.fillStyle = themeColors.sun; ctx.beginPath(); ctx.arc(canvas.width * 0.7, canvas.height * 0.2, 40, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = playerData.currentTheme === 'night' ? '#ccc' : '#fff'; 
            ctx.beginPath(); ctx.moveTo(0, canvas.height - 40); ctx.lineTo(canvas.width * 0.3, canvas.height * 0.4); ctx.lineTo(canvas.width * 0.6, canvas.height - 40); ctx.fill();
            ctx.fillStyle = themeColors.water; 
            ctx.beginPath(); ctx.moveTo(0, canvas.height - 40); ctx.lineTo(canvas.width * 0.3, canvas.height * 0.45); ctx.lineTo(canvas.width * 0.6, canvas.height - 40); ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for(let c of clouds) { c.x -= c.speed; if(c.x+c.w < 0) c.x=canvas.width; ctx.beginPath(); ctx.fillRect(c.x, c.y, c.w, 20); ctx.arc(c.x, c.y+10, 15, 0, Math.PI*2); ctx.arc(c.x+c.w, c.y+10, 15, 0, Math.PI*2); ctx.fill(); }
            ctx.fillStyle = themeColors.water; ctx.fillRect(0, canvas.height - 40, canvas.width, 40);
            ctx.fillStyle = playerData.currentTheme === 'night' ? '#aaa' : '#fff'; 
            let waveX = (frames * 2) % 40; for(let i = -40; i < canvas.width; i+=40) { ctx.beginPath(); ctx.arc(i - waveX, canvas.height - 35, 15, 0, Math.PI, false); ctx.fill(); }
        }

        function drawHealthBar() {
            const baseW = 200;
            const scaleFactor = maxHealth / baseMaxHealth; 
            const w = baseW * scaleFactor; 
            const h = 20; 
            const x = (canvas.width / 2) - (w / 2);
            const y = 60;

            ctx.lineWidth = 3; ctx.strokeStyle = themeColors.text; ctx.strokeRect(x, y, w, h);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fillRect(x, y, w, h);
            if (currentHealth > 0) {
                ctx.fillStyle = currentHealth > 30 ? '#c44e43' : '#8b0000';
                ctx.fillRect(x, y, (currentHealth/maxHealth)*w, h);
            }
            healthBarArea.style.width = w + 'px';
        }

        function gameOver() {
            gameState = 'over';
            playerData.totalCoins += runCoins;
            if (score > playerData.highScore) { playerData.highScore = score; highScoreEl.innerText = score; }
            
            // CHECKPOINT LOGIC: Save last boss stage
            if (score >= 25) {
                let bossStage = Math.floor(score / 25) * 25;
                if (bossStage >= 25) savedCheckpointScore = bossStage + 1;
            } else {
                savedCheckpointScore = 0;
            }

            saveData();
            
            cheatMode = false; cheatBtn.innerText = "Cheat Mode: OFF"; cheatBtn.className = "";
            
            shopOverlay.style.display = 'flex';
            instructionEl.style.display = 'none';
            document.getElementById('leftHint').style.display = 'none';
            document.getElementById('rightHint').style.display = 'none';
            if(fireInstructEl) fireInstructEl.style.display = 'none';
            updateShopUI();
        }

        function resetGame() {
            dragon.y = canvas.height / 2; dragon.velocity = 0; dragon.tailHistory = [];
            pipes.length = 0; enemies.length = 0; coins.length = 0; fireballs.length = 0; particles.length = 0;
            bossProjectiles = []; currentBoss = null;
            runCoins = 0; coinEl.innerText = 0; 
            
            // RESTORE SCORE FROM CHECKPOINT
            score = savedCheckpointScore;
            scoreEl.innerText = score;

            maxHealth = baseMaxHealth + (playerData.maxHealthLevel * 20); currentHealth = maxHealth;
            frames = 0; gameSpeed = 2.5; gameState = 'play';
            shopOverlay.style.display = 'none'; instructionEl.style.display = 'none';
            document.getElementById('rightHint').style.display = 'block';
            document.getElementById('leftHint').style.display = 'block';
            
            if (savedCheckpointScore > 0) {
                statusMessageEl.innerText = "Checkpoint Loaded!";
                statusMessageEl.style.display = 'block';
                setTimeout(() => statusMessageEl.style.display = 'none', 2000);
            }
        }

        function loop() {
            if (!isPaused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                if (gameState === 'play' || gameState === 'boss') {
                    dragon.update(); dragon.draw(); 
                    if(gameState==='boss') drawBoss();
                    handleGameLogic(); 
                    drawHealthBar(); frames++;
                    pipes.forEach(p => { if(!p.disabled) {
                        if(p.topHealth>0) drawBambooSegment(p.x, 0, pipeWidth, p.top, p.topHealth>2 ? false : true);
                        if(p.bottomHealth>0) drawBambooSegment(p.x, canvas.height-40-p.bottom, pipeWidth, p.bottom, p.bottomHealth>2 ? false : true);
                    }});
                    enemies.forEach(e => {
                        ctx.save(); ctx.translate(e.x,e.y); 
                        if (playerData.currentTheme === 'unicorn') {
                            ctx.fillStyle = '#636e72'; ctx.beginPath(); ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fill();
                            ctx.fillStyle = '#ff7675'; 
                            ctx.beginPath(); ctx.moveTo(-5,-3); ctx.lineTo(-2,2); ctx.lineTo(-8,2); ctx.fill(); 
                            ctx.beginPath(); ctx.moveTo(5,-3); ctx.lineTo(2,2); ctx.lineTo(8,2); ctx.fill(); 
                        } else {
                            const color = e.type===0 ? '#b83b3b':'#3b4bb8';
                            ctx.fillStyle=color; ctx.beginPath(); ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fill(); ctx.stroke(); 
                            ctx.fillStyle='#fff'; 
                            ctx.beginPath(); ctx.moveTo(-5,-10); ctx.lineTo(-8,-22); ctx.lineTo(0,-12); ctx.fill();
                            ctx.beginPath(); ctx.moveTo(5,-10); ctx.lineTo(8,-22); ctx.lineTo(0,-12); ctx.fill();
                            ctx.strokeStyle='#fff'; ctx.lineWidth=2;
                            ctx.beginPath(); ctx.moveTo(-8,-2); ctx.lineTo(-2,2); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(8,-2); ctx.lineTo(2,2); ctx.stroke();
                            ctx.strokeStyle='#000'; ctx.beginPath(); ctx.arc(0,5,5,Math.PI,0); ctx.stroke();
                        }
                        ctx.restore();
                    });
                    coins.forEach(c => drawCoin(c));
                    particles.forEach(p => { ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,4,4); });
                } else if (gameState === 'start') {
                    dragon.draw(); dragon.y = canvas.height/2 + Math.sin(Date.now()/300)*15;
                }
            }
            animationId = requestAnimationFrame(loop);
        }

        function handleInput(e) {
            if (shopOverlay.style.display === 'flex') return;
            if (mathOverlay.style.display === 'flex') return;
            if (isPaused) return;

            if (e.type === 'touchstart') e.preventDefault();
            e.stopPropagation();
            let clientX = 0;
            if (e.type === 'touchstart') clientX = e.changedTouches[0].clientX;
            else if (e.type === 'mousedown') clientX = e.clientX;
            else if (e.code === 'Space') clientX = canvas.width; 
            else if (e.code === 'KeyF') clientX = 0; 
            
            const isLeft = clientX < window.innerWidth / 2;
            
            if (gameState === 'start') {
                resetGame();
            } else if (gameState === 'play' || gameState === 'boss') {
                if (isLeft) {
                    dragon.shoot();
                } else {
                    dragon.flap();
                }
            }
        }

        window.addEventListener('touchstart', handleInput, {passive: false});
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'KeyF') handleInput(e);
        });

        loop();

    </script>
</body>
</html>
